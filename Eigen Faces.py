# -*- coding: utf-8 -*-
"""Final Assignment 2 code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mgRZOhYI8Gv-_3QVoJwGYKFQrnO6tb8w
"""

import os
import cv2
import numpy as np
import matplotlib
import matplotlib.pyplot as plt

dirNameTrain = '/face_data'


def CreateVector(images):
  len = images.shape[0]
  data = np.empty((0,256*256))
  for i in range(0,len):
    image = images[i]
    data_image = (image.reshape(1,-1))
    data = np.append(data,data_image,axis=0)
  return data

def ReadImages(path):
	# Create array of array of images.
  images = []
  for filePath in (os.listdir(path)):
    # Add to array of images
    imagePath = os.path.join(path, filePath)
    im = cv2.imread(imagePath)
    im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)
    images.append(im)

  return images


if __name__ == '__main__':
  #Get images is now images
  images = ReadImages(dirNameTrain)
  images = np.asarray(images)

  # Create Vector for PCA.
  face_vector = CreateVector(images)


  train_samples = face_vector[:157, :]
  test_samples = face_vector[157:,:]
  average_face_vector = np.mean(train_samples, axis=0)
  sub_face_vector = train_samples - average_face_vector
  covariance_matrix = np.dot(sub_face_vector, sub_face_vector.T)
  covariance_matrix = covariance_matrix/train_samples.shape[0]

  eigenValues,eigenVectors = np.linalg.eig(covariance_matrix)


  
  K = 30

# Select important eigen values
  selected_eigenVectors = eigenVectors[:, :K]

  eigen_faces = np.dot(sub_face_vector.T,selected_eigenVectors)

  eigen_faces_n = np.empty((256*256,30))

  norm = np.linalg.norm(eigen_faces,axis=0)
  for i in range(0,30):
    eigen_faces_n[:,i]=eigen_faces[:,i]/norm[i]


  eigen_faces_reshape=[]
  for i in range(0,10):
    eigen_faces_reshape.append(eigen_faces_n[:,i].reshape(256,256))

#Question Number 2.1:
  print("The top 10 eigen faces are as below:")
  for i in range(0,10):
    plt.imshow(eigen_faces_reshape[i],cmap='gray')
    plt.show()

#Question Number 2.2:
  mean_train = np.average(train_samples,axis=0)
  mean_test = np.average(test_samples,axis=0)
  Average_test_face  = (test_samples-mean_train)
  Average_test_face.shape

  reconstructed_image = np.dot(Average_test_face,eigen_faces_n)

  reconstructed_image = reconstructed_image.dot(eigen_faces_n.T)

  reconstructed_image = reconstructed_image + mean_train
  error = np.sum( np.sum((reconstructed_image - test_samples)**2 )) / 20
  r = reconstructed_image.reshape(20, 256, 256)
  plt.imshow(r[10], cmap='gray')

  for i in range(0,5):
    print("The",i," test faces is:")
    plt.imshow(test_samples[i].reshape(256,256),cmap='gray')
    plt.show()
    print("the",i," reconstructed image is:")
    plt.imshow(r[i],cmap='gray')
    plt.show()

#Question Number 2.3:
  K=[10,30,50,100,150]
  err_list=[]
  sub_face_vector = train_samples - average_face_vector
  for values in K:
    selected_eigenVectorsK = eigenVectors[:, :values]
    eigen_faces = np.dot(sub_face_vector.T,selected_eigenVectorsK)
    eigen_faces_n = np.empty((65536,values))
    for i in range(values):
      eigen_faces_n[:,i]=eigen_faces[:,i]/(np.linalg.norm(eigen_faces,axis=0)[i])
    mean_train = np.average(train_samples,axis=0)
    mean_test = np.average(test_samples,axis=0)
    Average_test_face  = (test_samples-mean_train)
    Average_test_face.shape
    reconstructed_image = np.matmul(Average_test_face,eigen_faces_n)
    reconstructed_image = reconstructed_image.dot(eigen_faces_n.T)
    reconstructed_image = reconstructed_image + mean_train
    error = np.sum( np.sum((reconstructed_image - test_samples)**2 )) / 20
    err_list.append(error)
  print(" The Reconstruction Error Curve is as Below:")
  plt.plot(K, err_list)
  print("This shows that the Reconstruction error decreases with K increases")